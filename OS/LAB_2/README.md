# Синхронизация потоков с помощью неименованных семафоров

Для обеспечения взаимного исключения при доступе нескольких потоков к одному критическому ресурсу используются семафоры.

Семафоры можно разделить на двоичные и общие, а также на неименованные и именованные.

Двоичный семафор – мьютекс – обладает только двумя состояниями – захвачен и свободен.
Если критический участок свободен, то поток выполняет операцию захвата мьютекса и входит в критический участок. При выходе из критического участка поток освобождает мьютекс.
Если критический участок занят, то поток, выполняя операцию захвата мьютекса, блокируется и не входит в критический участок. Активизация заблокированного потока и вход в критический участок происходит тогда, когда ранее вошедший в критический участок поток выходит из него и освобождает мьютекс.

Семафор отличается от мьютекса большим числом состояний за счет использования внутреннего счетчика. Это позволяет обеспечить большее разнообразие правил нахождения потоков в критическом участке.
При начальном состоянии счетчика семафора, равном 1, семафор эквивалентен мьютексу.

Мьютексы и неименованные семафоры используются для синхронизации потоков в рамках одного процесса.

Создание неименованного семафора производится вызовом:

```cpp
int sem_init(sem_t *sem, int shared, unsigned int value)
```
где:</br>
`sem` – идентификатор семафора;</br>
`shared` – индикатор использования семафора потоками или процессами;</br>
`value` – начальное значение счетчика семафора.

При входе в критический участок необходимо осуществить следующий вызов:

```cpp
int sem_wait(sem_t *sem).
```

При выходе из критического участка необходимо осуществить следующий вызов:
```cpp
int sem_post(sem_t *sem).
```

Удаление семафора производится вызовом:

```cpp
int sem_destroy(sem_t *sem).
```

## Устранение блокировок

Если поток, захвативший ресурс, завершится, не освободив его, например, аварийно, то потоки, ожидающие ресурс, т.е. вызвавшие операцию `sem_wait()`, так и останутся в заблокированном состоянии.
Устранить проблему позволяют неблокирующие операции проверки занятости ресурсов.

Для семафоров неблокирующими являются следующие функции:

```cpp
int sem_trywait(sem_t *sem);
```
Если ресурс свободен, то функция работает также как и функция `sem_wait()`. Если ресурс занят, то функция не блокируется в ожидании освобождения ресурса, а сразу же возвращает управление с кодом ошибки `EAGAIN`.

И функция:

```cpp
int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);
```

где:</br>
`clockid_t clk_id` тип часов, например, `CLOCK_REALTIME`,

время задается в виде структуры:

```cpp
struct timespec {
time_t   tv_sec;        /* секунды */
long     tv_nsec;       /* наносекунды */
};
```

Например, чтобы получить время ожидания 1 сек, надо выполнить следующие действия:

1. вызовом `clock_gettime` получить время в структуру `tp`,
2. выполнить операцию `tp.tv_sec += 1`,
3. передать модифицированное значение `tp` в функцию `sem_timedwait`.


## Указания к выполнению работы

Написать программу, содержащую два потока, осуществляющих координированный доступ к разделяемому ресурсу. В качестве разделяемого ресурса в данной работе выбирается экран.
Необходимо убедиться, что в случае отсутствия семафора потоки выводят символы  в произвольном порядке, например:

```bash
121212121212121212121212121212121212121212121212121212121212121
```

В случае использования семафора потоки выводят символы в определенном порядке, например:

```bash
111111111122222222221111111111222222222211111111112222222222
```

Студент реализует три варианта программы:

1.	С блокирующей операцией захвата семафора `sem_wait()`;
2.	С операцией проверки захвата семафора без блокировки `sem_trywait()`;
3.	С блокировкой на время операции захвата семафора `sem_timedwait()`.
