# Синхронизация процессов с помощью именованных семафоров

Именованные семафоры позволяют организовать синхронизацию процессов в операционной системе. За счет того, что при создании и открытии именованного семафора, ему передается «имя» - цепочка символов, два процесса получают возможность получить указатель на один и тот же семафор. Т.е. в отличие от мьютексов и неименованных семафоров, именованные семафоры могут координировать доступ к критическому ресурсу не только на уровне нескольких потоков одной программы, но и а на уровне нескольких, выполняющихся программ - процессов.
В системе этот семафор реализуется в виде специального файла, время жизни которого не ограничено временем жизни процесса, его создавшего.
Наиболее распространенными программными интерфейсами для создания именованных семафоров являются:


1.	интерфейс `POSIX` (Portable Operating System Interface) — переносимый интерфейс операционных систем — набор стандартов, описывающих интерфейсы между операционной системой и прикладной программой (системный `API`  (Application Programming Interface)) 
2.	интерфейс `SVID` (System V Interface Definition) стандарт, описывающий поведение ОС `UNIX` 

В стандарте `POSIX` именованный семафор создается следующим вызовом:
```C++
sem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value)
```
где:</br>
`name` – имя семафора;</br>
`oflag` – флаг, управляющий операцией создания семафора, при создании семафора необходимо указать флаг `O_CREAT`;</br>
`mode` – права доступа к семафору, могут быть установлены, например, в `0644`;</br>
`value` – начальное состояние семафора.</br>

Именованный семафор закрывается следующим вызовом:
```C++
int sem_close(sem_t *sem).
```
При входе в критический участок необходимо вызвать функцию:
```C++
int sem_wait(sem_t *sem).
```
При выходе из критического участка необходимо вызвать функцию:
```C++
int sem_post(sem_t *sem).
```
Именованный семафор удаляется следующим вызовом:
```C++
int sem_unlink(const char *name).
```
В стандарте `SVID` именованный семафор создается следующим вызовом:
```C++
int semget(key_t key, int nsems, int semflg);
```
где:</br>
`key_t key` - ключ для создания уникального объекта;</br>
`int nsems` – количество создаваемых семафоров;</br>
`int semflg`-  флаги управления доступом к семафору.</br>

Ключ должен быть получен функцией:
```C++
key_t ftok(const char *pathname, int proj_id);
```
где:</br>
`const char *pathname` – имя существующего файла;</br>
`int proj_id` – идентификатор проекта.</br>

При задании в двух программах одинакового имени файла и одинакового идентификатора проекта функция возвращает в этих программах одинаковый ключ. 

Захват и освобождение семафора выполняется одной и той же функцией следующего вида:
```C++
int semop(int semid, struct sembuf *sops, unsigned nsops);
```
где:</br>
`int semid` – идентификатор семафора, возвращаемый функцией `semget()`;</br>
`struct sembuf *sops` – указатель на структуру, определяющую операции, которые надо выполнить с семафором;</br>
`unsigned nsops` – количество операций.</br>

Структура struct sembuf имеет следующий вид:
```C++
struct sembuf {
    short sem_num;
    short sem_op;
    short sem_flg;
};
```
где:</br>
`short sem_num` – номер семафора, над которым делается операция;</br>
`short sem_op` – вид операции над семафором;</br>
`short sem_flg` – флаги операции.</br>

Три вида операций могут быть выполнены над семафором:
1.	если `sem_op = 0`, то процесс ждет, пока семафор не обнулится;
2.	если `sem_op > 0`, то текущее значение семафора увеличивается на величину sem_op;
3.	если `sem_op < 0`, то процесс ждет, пока значение семафора не станет или равным абсолютной величине `sem_op`. Затем абсолютная величина `sem_op` вычитается из значения семафора.

Пусть значение семафора `0` означает, что ресурс свободен, а значение `1` означает, что ресурс занят.

Создадим структуру следующего вида:
```C++
struct sembuf lock[2] = {
0,0,0, //ждать обнуления семафора
0,1,0  //увеличить значение семафора на 1
};
```
Тогда следующая операция будет захватывать ресурс:
```C++
semop(semid,&lock[0],2);
```
Введем структуру следующего вида:
```C++
struct sembuf unlock[1] = {
    0,-1,0, //обнулить семафор
};
```
Тогда следующая операция будет освобождать ресурс:
```C++
semop(semid,&unlock[0],1);
```
По окончанию работы с семафором его необходимо удалить функцией:
```C++
int semctl(int semid, int semnum, int cmd);
```
где:</br>
`int semid` – идентификатор удаляемой группы семафоров;</br>
`int semnum` – номер семафора – игнорируется для команды `IPC_RMID`;</br>
`int cmd` – команда, которая в случае удаления принимает значение `IPC_RMID`.</br>
