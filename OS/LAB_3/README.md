# Взаимодействие потоков через неименованные каналы

Одним из средств взаимодействия процессов и потоков является неименованный канал. Канал не только обеспечивает передачу данных, но и поддерживает синхронизацию между потоками и процессами. Свойствами канала являются следующие положения «при попытке записать данные в полный канал процесс блокируется» и «при попытке чтения данных из пустого канала процесс блокируется».

Канал создается с помощью следующего вызова:
```cpp
int pipe(int filedes[2]),
```
где:</br>
`filedes[2]` – массив из двух файловых дескрипторов, один из которых используется для записи данных `filedes[1]`, а второй `filedes[0]` – для чтения данных.

Чтение данных из канала производится следующей операцией:
```cpp
ssize_t read(int fd, void *buf, size_t count),
```

Запись данных в канал производится следующей операцией:

```cpp
ssize_t write(int fd, const void *buf, size_t count),
```

где:</br>
`fd` – файловый дескриптор для чтения;</br>
`buf` – адрес буфера для чтения данных;</br>
`count` – размер буфера.</br>

Каждый из дескрипторов канала отдельно закрывается следующим вызовом:
```cpp
int close(int fd).
```

## Устранение блокировок

Блокировки потока при чтении из пустого канала или при записи в полный канал обладают и недостатками.
В первом случае, если никакой поток не запишет данные в пустой канал, то поток, ожидающий чтение, так и останется заблокированным. Аналогично, если никакой поток не прочитает данные из полного канала, то поток, ожидающие запись, так и останется заблокированным. Избежать указанных недостатков позволяют неблокирующие операции чтения и записи.

Реализовать неблокирующие операции чтения и записи в неименованном канале можно следующими способами.
1.	Использовать следующую функцию создания неименованного канала вместо ранее приведенной функции:
```cpp
int pipe2(int pipefd[2], int flags);
```
где в качестве параметра `int flags` передать значение `O_NONBLOCK`, обеспечивающее неблокируемое состояние операций чтения и записи для созданных дескрипторов.

2.	Использовать следующую функцию для установления флагов состояния дескрипторов:
```cpp
int fcntl(int fd, int cmd, ... /* arg */ 
```
где в качестве параметра `int cmd` можно передать команду `F_SETFL`, `F_GETFL` установки флагов состояния дескриптора, а в списке аргументов можно передать флаг `O_NONBLOCK`. Второй вариант является более предпочтительным, чем первый, поскольку является универсальным, не ориентированным исключительно на `Linux`.

## Запись сообщения в неименованный канал

В качестве сообщения передается результат выполнения функции `getpwuid_r()`.

```cpp
getpwuid_r(getuid(), &pwent, buf, sizeof buf, &pwentp);
```

Функция `getpwuid_r()` по функции `getuid()` принимает `userID` и по `userID` получает данные пользователя в структуру данных `struct passwd`.

```cpp
struct passwd {
    char    *pw_name;       // имя пользователя 
    char    *pw_passwd;     // пароль пользователя 
    uid_t   pw_uid;         // id пользователя 
    gid_t   pw_gid;         // id группы 
    char    *pw_gecos;      // настоящее имя 
    char    *pw_dir;        // домашний каталог 
    char    *pw_shell;      // программа-оболочка 
};
```

Далее из этих данных формируется строка, записываются в буфер и передается в неименованный канал.
```cpp
int message = sprintf(buf, "%s\n%s\n", pwent.pw_name, pwent.pw_shell);
write(field[1], buf, message);
```

## Чтения сообщения из неименованного канала

Чтение из неименованного канала в буфер выполняется по функции `read`, проверяется возвращаемое значение, если все хорошо, сообщение выводится на экран. После вывода буфера очищается.

```cpp
int res = read(field[0], buf, BUFF_SIZE);     
if (res == 0) {
    printf("End of file, read channel was closed");
    sleep(1);
}
if (res == -1) {
    perror("read");
    printf("\n\r");
    exit(EXIT_FAILURE);
}
else {
    printf("%s\n", buf);           
}
sleep(1);
memset(buf, 0, BUFF_SIZE);
```

Реализованы три варианта программы:
1. [С блокировкой с функцией pipe(field)](./lab3_1.cpp)
2. [Без блокировки с функцией pipe2(field, O_NONBLOCK](./lab3_2.cpp)
3. [Без блокировки с функцией fcntl(field, ...)](./lab3_3.cpp)

```cpp
result = pipe(field);
if (result != 0) {      //linux man: 0 is ok, -1 is error
    perror("pipe2");
    return -1;
}

int fl1 = fcntl(field[0], F_GETFL);
int fl2 = fcntl(field[1], F_SETFL);

fcntl(field[0], F_GETFL, fl1 | O_NONBLOCK);
fcntl(field[1], F_SETFL, fl2 | O_NONBLOCK);
```